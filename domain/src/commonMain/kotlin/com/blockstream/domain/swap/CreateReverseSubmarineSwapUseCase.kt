package com.blockstream.domain.swap

import com.blockstream.data.data.GreenWallet
import com.blockstream.data.data.SwapType
import com.blockstream.data.database.Database
import com.blockstream.data.gdk.GdkSession
import com.blockstream.data.gdk.data.Account
import lwk.InvoiceResponse

/**
 * Creates a Reverse Submarine Swap to receive Lightning funds into an on-chain account.
 *
 * In a Reverse Submarine Swap, the user pays a Lightning invoice (generated by this use case)
 * and receives funds at an on-chain address after the swap provider locks up and claims the
 * transaction. The swap metadata is persisted in the database for tracking by background workers.
 */
class CreateReverseSubmarineSwapUseCase(
    private val database: Database
) {
    /**
     * Generates a reverse swap invoice via LWK and persists the metadata to the database.
     *
     * @param wallet the active [GreenWallet] identifying the user's wallet
     * @param session the current [GdkSession] providing access to the LWK
     * @param account the on-chain [Account] where the swapped funds will eventually be received
     * @param amount the amount the user wants to receive (in satoshis)
     * @param description an optional description to be included in the BOLT11 invoice
     * @return the [InvoiceResponse] containing the generated BOLT11 invoice and swap identifier
     * @throws Exception if required session data (like xPubHashId) is missing
     */
    suspend operator fun invoke(
        wallet: GreenWallet,
        session: GdkSession,
        isAutoSwap: Boolean,
        account: Account,
        amount: Long,
        description: String? = null
    ): InvoiceResponse {

        val xPubHashId = session.xPubHashId ?: throw Exception("xPubHashId should not be null")

        val invoice = session.lwk.createReverseSubmarineSwap(
            address = session.getReceiveAddress(account).address,
            amount = amount,
            description = description
        )

        database.setSwap(
            id = invoice.swapId(),
            walletId = wallet.id,
            xPubHashId = xPubHashId,
            swapType = SwapType.ReverseSubmarine,
            isAutoSwap = isAutoSwap,
            data = invoice.serialize()
        )

        return invoice
    }
}
