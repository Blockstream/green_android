/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.blockstream.libwally;

public class Wally {

    private static boolean loadLibrary() {
        try {
            System.loadLibrary("greenaddress");
            return true;
        } catch (final UnsatisfiedLinkError e) {
            System.err.println("Native code library failed to load.\n" + e);
            return false;
        }
    }

    private static final boolean enabled = loadLibrary();
    public static boolean isEnabled() {
        return enabled;
    }

    static final class Obj {
        private final transient long ptr;
        private final int id;
        private Obj(final long ptr, final int id) { this.ptr = ptr; this.id = id; }
        private long get() { return ptr; }
        private int get_id() { return id; }
    }

  public final static native void init(long jarg1);
  public final static native int _cleanup(long jarg1);
  public final static native void secp_randomize(byte[] jarg1);
  public final static native void hex_verify(String jarg1);
  public final static native void hex_n_verify(String jarg1, long jarg2);
  public final static native String hex_from_bytes(byte[] jarg1);
  public final static native int hex_to_bytes(String jarg1, byte[] jarg2);
  public final static native int hex_n_to_bytes(String jarg1, long jarg2, byte[] jarg3);
  public final static native String base58_from_bytes(byte[] jarg1, long jarg3);
  public final static native int base58_to_bytes(String jarg1, long jarg2, byte[] jarg3);
  public final static native int base58_n_to_bytes(String jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int base58_get_length(String jarg1);
  public final static native int base58_n_get_length(String jarg1, long jarg2);
  public final static native String base64_from_bytes(byte[] jarg1, long jarg3);
  public final static native int base64_to_bytes(String jarg1, long jarg2, byte[] jarg3);
  public final static native int base64_get_maximum_length(String jarg1, long jarg2);
  public final static native int _is_elements_build();
  public final static native String addr_segwit_from_bytes(byte[] jarg1, String jarg3, long jarg4);
  public final static native int addr_segwit_to_bytes(String jarg1, String jarg2, long jarg3, byte[] jarg4);
  public final static native int addr_segwit_n_to_bytes(String jarg1, long jarg2, String jarg3, long jarg4, long jarg5, byte[] jarg6);
  public final static native int addr_segwit_get_version(String jarg1, String jarg2, long jarg3);
  public final static native int addr_segwit_n_get_version(String jarg1, long jarg2, String jarg3, long jarg4, long jarg5);
  public final static native int address_to_scriptpubkey(String jarg1, long jarg2, byte[] jarg3);
  public final static native String scriptpubkey_to_address(byte[] jarg1, long jarg3);
  public final static native String wif_from_bytes(byte[] jarg1, long jarg3, long jarg4);
  public final static native int wif_to_bytes(String jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int _wif_is_uncompressed(String jarg1);
  public final static native int wif_to_public_key(String jarg1, long jarg2, byte[] jarg3);
  public final static native String bip32_key_to_address(Object jarg1, long jarg2, long jarg3);
  public final static native String bip32_key_to_addr_segwit(Object jarg1, String jarg2, long jarg3);
  public final static native String wif_to_address(String jarg1, long jarg2, long jarg3);
  public final static native String confidential_addr_to_addr(String jarg1, long jarg2);
  public final static native byte[] confidential_addr_to_ec_public_key(String jarg1, long jarg2, byte[] jarg3);
  public final static native String confidential_addr_from_addr(String jarg1, long jarg2, byte[] jarg3);
  public final static native String confidential_addr_to_addr_segwit(String jarg1, String jarg2, String jarg3);
  public final static native byte[] confidential_addr_segwit_to_ec_public_key(String jarg1, String jarg2, byte[] jarg3);
  public final static native String confidential_addr_from_addr_segwit(String jarg1, String jarg2, String jarg3, byte[] jarg4);
  public final static native byte[] ae_host_commit_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native byte[] ae_signer_commit_from_bytes(byte[] jarg1, byte[] jarg3, byte[] jarg5, long jarg7, byte[] jarg8);
  public final static native byte[] ae_sig_from_bytes(byte[] jarg1, byte[] jarg3, byte[] jarg5, long jarg7, byte[] jarg8);
  public final static native void ae_verify(byte[] jarg1, byte[] jarg3, byte[] jarg5, byte[] jarg7, long jarg9, byte[] jarg10);
  public final static native void bip32_key_free(Object jarg1);
  public final static native Object bip32_key_init(long jarg1, long jarg2, long jarg3, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10, byte[] jarg12);
  public final static native Object bip32_key_from_seed_custom(byte[] jarg1, long jarg3, byte[] jarg4, long jarg6);
  public final static native Object bip32_key_from_seed(byte[] jarg1, long jarg3, long jarg4);
  public final static native byte[] bip32_key_serialize(Object jarg1, long jarg2, byte[] jarg3);
  public final static native Object bip32_key_unserialize(byte[] jarg1);
  public final static native Object bip32_key_from_parent(Object jarg1, long jarg2, long jarg3);
  public final static native Object bip32_key_from_parent_path(Object jarg1, int[] jarg2, long jarg4);
  public final static native Object bip32_key_from_parent_path_str(Object jarg1, String jarg2, long jarg3, long jarg4);
  public final static native Object bip32_key_from_parent_path_str_n(Object jarg1, String jarg2, long jarg3, long jarg4, long jarg5);
  public final static native Object bip32_key_with_tweak_from_parent_path(Object jarg1, int[] jarg2, long jarg4);
  public final static native String bip32_key_to_base58(Object jarg1, long jarg2);
  public final static native Object bip32_key_from_base58(String jarg1);
  public final static native Object bip32_key_from_base58_n(String jarg1, long jarg2);
  public final static native void bip32_key_strip_private_key(Object jarg1);
  public final static native byte[] bip32_key_get_fingerprint(Object jarg1, byte[] jarg2);
  public final static native int bip32_path_from_str(String jarg1, long jarg2, long jarg3, long jarg4, long jarg5, long jarg6);
  public final static native int bip32_path_from_str_n(String jarg1, long jarg2, long jarg3, long jarg4, long jarg5, long jarg6, long jarg7);
  public final static native int bip32_path_str_get_features(String jarg1);
  public final static native int bip32_path_str_n_get_features(String jarg1, long jarg2);
  public final static native byte[] bip32_key_get_chain_code(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_parent160(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_priv_key(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_hash160(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_pub_key(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_pub_key_tweak_sum(Object jarg1, byte[] jarg2);
  public final static native int bip32_key_get_depth(Object jarg1);
  public final static native int bip32_key_get_child_num(Object jarg1);
  public final static native int bip32_key_get_version(Object jarg1);
  public final static native byte[] bip38_raw_from_private_key(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native String bip38_from_private_key(byte[] jarg1, byte[] jarg3, long jarg5);
  public final static native byte[] bip38_raw_to_private_key(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] bip38_to_private_key(String jarg1, byte[] jarg2, long jarg4, byte[] jarg5);
  public final static native int bip38_raw_get_flags(byte[] jarg1);
  public final static native int bip38_get_flags(String jarg1);
  public final static native String bip39_get_languages();
  public final static native Object bip39_get_wordlist(String jarg1);
  public final static native String bip39_get_word(Object jarg1, long jarg2);
  public final static native String bip39_mnemonic_from_bytes(Object jarg1, byte[] jarg2);
  public final static native int bip39_mnemonic_to_bytes(Object jarg1, String jarg2, byte[] jarg3);
  public final static native void bip39_mnemonic_validate(Object jarg1, String jarg2);
  public final static native int bip39_mnemonic_to_seed(String jarg1, String jarg2, byte[] jarg3);
  public final static native byte[] bip39_mnemonic_to_seed512(String jarg1, String jarg2, byte[] jarg3);
  public final static native String bip85_get_languages();
  public final static native int bip85_get_bip39_entropy(Object jarg1, String jarg2, long jarg3, long jarg4, byte[] jarg5);
  public final static native int coinselect_assets(long[] jarg1, long jarg3, long jarg4, long jarg5, int[] jarg6);
  public final static native void scrypt(byte[] jarg1, byte[] jarg3, long jarg5, long jarg6, long jarg7, byte[] jarg8);
  public final static native byte[] aes(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native int aes_cbc(byte[] jarg1, byte[] jarg3, byte[] jarg5, long jarg7, byte[] jarg8);
  public final static native byte[] sha256(byte[] jarg1, byte[] jarg3);
  public final static native byte[] sha256_midstate(byte[] jarg1, byte[] jarg3);
  public final static native byte[] sha256d(byte[] jarg1, byte[] jarg3);
  public final static native byte[] sha512(byte[] jarg1, byte[] jarg3);
  public final static native byte[] bip340_tagged_hash(byte[] jarg1, String jarg3, byte[] jarg4);
  public final static native byte[] ripemd160(byte[] jarg1, byte[] jarg3);
  public final static native byte[] hash160(byte[] jarg1, byte[] jarg3);
  public final static native byte[] hmac_sha256(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] hmac_sha512(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] pbkdf2_hmac_sha256(byte[] jarg1, byte[] jarg3, long jarg5, long jarg6, byte[] jarg7);
  public final static native byte[] pbkdf2_hmac_sha512(byte[] jarg1, byte[] jarg3, long jarg5, long jarg6, byte[] jarg7);
  public final static native void ec_private_key_verify(byte[] jarg1);
  public final static native void ec_public_key_verify(byte[] jarg1);
  public final static native void ec_xonly_public_key_verify(byte[] jarg1);
  public final static native byte[] ec_public_key_from_private_key(byte[] jarg1, byte[] jarg3);
  public final static native byte[] ec_public_key_decompress(byte[] jarg1, byte[] jarg3);
  public final static native byte[] ec_public_key_negate(byte[] jarg1, byte[] jarg3);
  public final static native byte[] ec_public_key_bip341_tweak(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] ec_private_key_bip341_tweak(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native int ec_sig_from_bytes_len(byte[] jarg1, byte[] jarg3, long jarg5);
  public final static native byte[] ec_sig_from_bytes(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native int ec_sig_from_bytes_aux_len(byte[] jarg1, byte[] jarg3, byte[] jarg5, long jarg7);
  public final static native byte[] ec_sig_from_bytes_aux(byte[] jarg1, byte[] jarg3, byte[] jarg5, long jarg7, byte[] jarg8);
  public final static native byte[] ec_sig_normalize(byte[] jarg1, byte[] jarg3);
  public final static native int ec_sig_to_der(byte[] jarg1, byte[] jarg3);
  public final static native byte[] ec_sig_from_der(byte[] jarg1, byte[] jarg3);
  public final static native void ec_sig_verify(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] ec_sig_to_public_key(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native void ec_scalar_verify(byte[] jarg1);
  public final static native byte[] ec_scalar_add(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] ec_scalar_subtract(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] ec_scalar_multiply(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native int format_bitcoin_message(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native byte[] ecdh(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] s2c_sig_from_bytes(byte[] jarg1, byte[] jarg3, byte[] jarg5, long jarg7, byte[] jarg8, byte[] jarg10);
  public final static native void s2c_commitment_verify(byte[] jarg1, byte[] jarg3, byte[] jarg5, long jarg7);
  public final static native Object descriptor_parse(String jarg1, Object jarg2, long jarg3, long jarg4);
  public final static native void descriptor_free(Object jarg1);
  public final static native String descriptor_canonicalize(Object jarg1, long jarg2);
  public final static native String descriptor_get_checksum(Object jarg1, long jarg2);
  public final static native int descriptor_get_network(Object jarg1);
  public final static native void descriptor_set_network(Object jarg1, long jarg2);
  public final static native int descriptor_get_features(Object jarg1);
  public final static native int descriptor_get_num_variants(Object jarg1);
  public final static native int descriptor_get_num_paths(Object jarg1);
  public final static native int descriptor_get_depth(Object jarg1);
  public final static native int descriptor_to_script_get_maximum_length(Object jarg1, long jarg2, long jarg3, long jarg4, long jarg5, long jarg6, long jarg7);
  public final static native int descriptor_to_script(Object jarg1, long jarg2, long jarg3, long jarg4, long jarg5, long jarg6, long jarg7, byte[] jarg8);
  public final static native String descriptor_to_address(Object jarg1, long jarg2, long jarg3, long jarg4, long jarg5);
  public final static native String[] descriptor_to_addresses(Object jarg1, long jarg2, long jarg3, long jarg4, long jarg5, long jarg6);
  public final static native Object map_init(long jarg1, long jarg2);
  public final static native void map_free(Object jarg1);
  public final static native void map_clear(Object jarg1);
  public final static native void map_add(Object jarg1, byte[] jarg2, byte[] jarg4);
  public final static native void map_add_integer(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void map_replace(Object jarg1, byte[] jarg2, byte[] jarg4);
  public final static native void map_replace_integer(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void map_remove(Object jarg1, byte[] jarg2);
  public final static native void map_remove_integer(Object jarg1, long jarg2);
  public final static native int map_find_from(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int map_find(Object jarg1, byte[] jarg2);
  public final static native int map_find_integer(Object jarg1, long jarg2);
  public final static native int map_get_num_items(Object jarg1);
  public final static native int map_get_item_key_length(Object jarg1, long jarg2);
  public final static native int map_get_item_key(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int map_get_item_integer_key(Object jarg1, long jarg2);
  public final static native int map_get_item_length(Object jarg1, long jarg2);
  public final static native int map_get_item(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void map_sort(Object jarg1, long jarg2);
  public final static native void map_combine(Object jarg1, Object jarg2);
  public final static native void map_assign(Object jarg1, Object jarg2);
  public final static native int map_find_bip32_public_key_from(Object jarg1, long jarg2, Object jarg3);
  public final static native Object map_keypath_get_bip32_key_from(Object jarg1, long jarg2, Object jarg3);
  public final static native void keypath_bip32_verify(byte[] jarg1, byte[] jarg3);
  public final static native void keypath_public_key_verify(byte[] jarg1, byte[] jarg3);
  public final static native void merkle_path_xonly_public_key_verify(byte[] jarg1, byte[] jarg3);
  public final static native Object map_keypath_bip32_init(long jarg1);
  public final static native Object map_keypath_public_key_init(long jarg1);
  public final static native void map_keypath_add(Object jarg1, byte[] jarg2, byte[] jarg4, int[] jarg6);
  public final static native void map_merkle_path_add(Object jarg1, byte[] jarg2, byte[] jarg4);
  public final static native byte[] keypath_get_fingerprint(byte[] jarg1, byte[] jarg3);
  public final static native byte[] map_keypath_get_item_fingerprint(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int keypath_get_path_len(byte[] jarg1);
  public final static native int map_keypath_get_item_path_len(Object jarg1, long jarg2);
  public final static native int keypath_get_path(byte[] jarg1, int[] jarg3);
  public final static native int map_keypath_get_item_path(Object jarg1, long jarg2, int[] jarg3);
  public final static native void map_hash_preimage_verify(byte[] jarg1, byte[] jarg3);
  public final static native Object map_preimage_init(long jarg1);
  public final static native void map_preimage_ripemd160_add(Object jarg1, byte[] jarg2);
  public final static native void map_preimage_sha256_add(Object jarg1, byte[] jarg2);
  public final static native void map_preimage_hash160_add(Object jarg1, byte[] jarg2);
  public final static native void map_preimage_sha256d_add(Object jarg1, byte[] jarg2);
  public final static native Object psbt_init(long jarg1, long jarg2, long jarg3, long jarg4, long jarg5);
  public final static native void psbt_free(Object jarg1);
  public final static native void psbt_set_version(Object jarg1, long jarg2, long jarg3);
  public final static native byte[] psbt_get_id(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_locktime(Object jarg1);
  public final static native int psbt_is_finalized(Object jarg1);
  public final static native void psbt_set_global_tx(Object jarg1, Object jarg2);
  public final static native void psbt_set_tx_version(Object jarg1, long jarg2);
  public final static native int psbt_get_tx_version(Object jarg1);
  public final static native void psbt_set_fallback_locktime(Object jarg1, long jarg2);
  public final static native void psbt_clear_fallback_locktime(Object jarg1);
  public final static native void psbt_set_tx_modifiable_flags(Object jarg1, long jarg2);
  public final static native void psbt_set_global_scalars(Object jarg1, Object jarg2);
  public final static native void psbt_add_global_scalar(Object jarg1, byte[] jarg2);
  public final static native int psbt_find_global_scalar(Object jarg1, byte[] jarg2);
  public final static native void psbt_set_pset_modifiable_flags(Object jarg1, long jarg2);
  public final static native void psbt_add_input_taproot_keypath(Object jarg1, long jarg2, long jarg3, byte[] jarg4, byte[] jarg6, byte[] jarg8, int[] jarg10);
  public final static native void psbt_add_tx_input_at(Object jarg1, long jarg2, long jarg3, Object jarg4);
  public final static native void psbt_remove_input(Object jarg1, long jarg2);
  public final static native Object psbt_get_input_bip32_key_from(Object jarg1, long jarg2, long jarg3, long jarg4, Object jarg5);
  public final static native int psbt_get_input_signing_script_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_signing_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_scriptcode_len(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_scriptcode(Object jarg1, long jarg2, byte[] jarg3, byte[] jarg5);
  public final static native int psbt_get_input_signature_hash(Object jarg1, long jarg2, Object jarg3, byte[] jarg4, long jarg6, byte[] jarg7);
  public final static native void psbt_add_output_taproot_keypath(Object jarg1, long jarg2, long jarg3, byte[] jarg4, byte[] jarg6, byte[] jarg8, int[] jarg10);
  public final static native void psbt_add_tx_output_at(Object jarg1, long jarg2, long jarg3, Object jarg4);
  public final static native void psbt_remove_output(Object jarg1, long jarg2);
  public final static native Object psbt_from_bytes(byte[] jarg1, long jarg3);
  public final static native int psbt_get_length(Object jarg1, long jarg2);
  public final static native int psbt_to_bytes(Object jarg1, long jarg2, byte[] jarg3);
  public final static native Object psbt_from_base64(String jarg1, long jarg2);
  public final static native String psbt_to_base64(Object jarg1, long jarg2);
  public final static native void psbt_combine(Object jarg1, Object jarg2);
  public final static native Object psbt_clone(Object jarg1, long jarg2);
  public final static native Object psbt_blind(Object jarg1, Object jarg2, Object jarg3, Object jarg4, Object jarg5, byte[] jarg6, long jarg8, long jarg9);
  public final static native void psbt_sign(Object jarg1, byte[] jarg2, long jarg4);
  public final static native void psbt_sign_bip32(Object jarg1, Object jarg2, long jarg3);
  public final static native void psbt_sign_input_bip32(Object jarg1, long jarg2, long jarg3, byte[] jarg4, Object jarg6, long jarg7);
  public final static native void psbt_finalize(Object jarg1, long jarg2);
  public final static native void psbt_finalize_input(Object jarg1, long jarg2, long jarg3);
  public final static native Object psbt_extract(Object jarg1, long jarg2);
  public final static native int psbt_is_elements(Object jarg1);
  public final static native Object psbt_get_global_tx(Object jarg1);
  public final static native int psbt_get_version(Object jarg1);
  public final static native int psbt_get_num_inputs(Object jarg1);
  public final static native int psbt_get_num_outputs(Object jarg1);
  public final static native int psbt_get_fallback_locktime(Object jarg1);
  public final static native int psbt_has_fallback_locktime(Object jarg1);
  public final static native int psbt_get_tx_modifiable_flags(Object jarg1);
  public final static native int psbt_get_global_scalars_size(Object jarg1);
  public final static native byte[] psbt_get_global_scalar(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_pset_modifiable_flags(Object jarg1);
  public final static native Object psbt_get_input_utxo(Object jarg1, long jarg2);
  public final static native Object psbt_get_input_witness_utxo(Object jarg1, long jarg2);
  public final static native Object psbt_get_input_best_utxo(Object jarg1, long jarg2);
  public final static native int psbt_get_input_redeem_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_redeem_script_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_witness_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_witness_script_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_final_scriptsig(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_final_scriptsig_len(Object jarg1, long jarg2);
  public final static native Object psbt_get_input_final_witness(Object jarg1, long jarg2);
  public final static native int psbt_get_input_keypaths_size(Object jarg1, long jarg2);
  public final static native int psbt_find_input_keypath(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_keypath(Object jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int psbt_get_input_keypath_len(Object jarg1, long jarg2, long jarg3);
  public final static native int psbt_get_input_signatures_size(Object jarg1, long jarg2);
  public final static native int psbt_find_input_signature(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_signature(Object jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int psbt_get_input_signature_len(Object jarg1, long jarg2, long jarg3);
  public final static native int psbt_get_input_taproot_signature(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_taproot_signature_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_unknowns_size(Object jarg1, long jarg2);
  public final static native int psbt_find_input_unknown(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_unknown(Object jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int psbt_get_input_unknown_len(Object jarg1, long jarg2, long jarg3);
  public final static native int psbt_get_input_sighash(Object jarg1, long jarg2);
  public final static native byte[] psbt_get_input_previous_txid(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_output_index(Object jarg1, long jarg2);
  public final static native int psbt_get_input_sequence(Object jarg1, long jarg2);
  public final static native int psbt_get_input_required_locktime(Object jarg1, long jarg2);
  public final static native int psbt_get_input_required_lockheight(Object jarg1, long jarg2);
  public final static native void psbt_set_input_utxo(Object jarg1, long jarg2, Object jarg3);
  public final static native void psbt_set_input_witness_utxo(Object jarg1, long jarg2, Object jarg3);
  public final static native void psbt_set_input_witness_utxo_from_tx(Object jarg1, long jarg2, Object jarg3, long jarg4);
  public final static native void psbt_set_input_redeem_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_set_input_witness_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_set_input_final_scriptsig(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_set_input_final_witness(Object jarg1, long jarg2, Object jarg3);
  public final static native void psbt_set_input_keypaths(Object jarg1, long jarg2, Object jarg3);
  public final static native void psbt_set_input_signatures(Object jarg1, long jarg2, Object jarg3);
  public final static native void psbt_set_input_taproot_signature(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_add_input_signature(Object jarg1, long jarg2, byte[] jarg3, byte[] jarg5);
  public final static native void psbt_set_input_unknowns(Object jarg1, long jarg2, Object jarg3);
  public final static native void psbt_set_input_sighash(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_set_input_previous_txid(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_set_input_output_index(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_set_input_sequence(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_clear_input_sequence(Object jarg1, long jarg2);
  public final static native void psbt_set_input_required_locktime(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_clear_input_required_locktime(Object jarg1, long jarg2);
  public final static native int psbt_has_input_required_locktime(Object jarg1, long jarg2);
  public final static native void psbt_set_input_required_lockheight(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_clear_input_required_lockheight(Object jarg1, long jarg2);
  public final static native int psbt_has_input_required_lockheight(Object jarg1, long jarg2);
  public final static native long psbt_get_input_amount(Object jarg1, long jarg2);
  public final static native int psbt_get_input_amount_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_amount_rangeproof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_asset(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_asset_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_asset_surjectionproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_asset_surjectionproof_len(Object jarg1, long jarg2);
  public final static native long psbt_get_input_issuance_amount(Object jarg1, long jarg2);
  public final static native long psbt_get_input_inflation_keys(Object jarg1, long jarg2);
  public final static native long psbt_get_input_pegin_amount(Object jarg1, long jarg2);
  public final static native int psbt_get_input_pegin_txout_proof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_pegin_txout_proof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_pegin_genesis_blockhash(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_pegin_genesis_blockhash_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_pegin_claim_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_pegin_claim_script_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_issuance_amount_commitment(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_issuance_amount_commitment_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_issuance_amount_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_issuance_amount_rangeproof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_issuance_blinding_nonce(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_issuance_blinding_nonce_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_issuance_asset_entropy(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_issuance_asset_entropy_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_issuance_amount_blinding_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_issuance_amount_blinding_rangeproof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_inflation_keys_commitment(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_inflation_keys_commitment_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_inflation_keys_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_inflation_keys_rangeproof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_inflation_keys_blinding_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_inflation_keys_blinding_rangeproof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_input_utxo_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_input_utxo_rangeproof_len(Object jarg1, long jarg2);
  public final static native void psbt_set_input_amount(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_clear_input_amount(Object jarg1, long jarg2);
  public final static native void psbt_set_input_amount_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_amount_rangeproof(Object jarg1, long jarg2);
  public final static native void psbt_set_input_asset(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_asset(Object jarg1, long jarg2);
  public final static native void psbt_set_input_asset_surjectionproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_asset_surjectionproof(Object jarg1, long jarg2);
  public final static native void psbt_set_input_issuance_amount(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_set_input_inflation_keys(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_set_input_pegin_amount(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_set_input_pegin_txout_proof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_pegin_txout_proof(Object jarg1, long jarg2);
  public final static native void psbt_set_input_pegin_genesis_blockhash(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_pegin_genesis_blockhash(Object jarg1, long jarg2);
  public final static native void psbt_set_input_pegin_claim_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_pegin_claim_script(Object jarg1, long jarg2);
  public final static native void psbt_set_input_issuance_amount_commitment(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_issuance_amount_commitment(Object jarg1, long jarg2);
  public final static native void psbt_set_input_issuance_amount_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_issuance_amount_rangeproof(Object jarg1, long jarg2);
  public final static native void psbt_set_input_issuance_blinding_nonce(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_issuance_blinding_nonce(Object jarg1, long jarg2);
  public final static native void psbt_set_input_issuance_asset_entropy(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_issuance_asset_entropy(Object jarg1, long jarg2);
  public final static native void psbt_set_input_issuance_amount_blinding_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_issuance_amount_blinding_rangeproof(Object jarg1, long jarg2);
  public final static native void psbt_set_input_inflation_keys_commitment(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_inflation_keys_commitment(Object jarg1, long jarg2);
  public final static native void psbt_set_input_inflation_keys_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_inflation_keys_rangeproof(Object jarg1, long jarg2);
  public final static native void psbt_set_input_inflation_keys_blinding_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_inflation_keys_blinding_rangeproof(Object jarg1, long jarg2);
  public final static native void psbt_set_input_utxo_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_input_utxo_rangeproof(Object jarg1, long jarg2);
  public final static native void psbt_generate_input_explicit_proofs(Object jarg1, long jarg2, long jarg3, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10);
  public final static native int psbt_get_output_redeem_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_redeem_script_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_witness_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_witness_script_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_keypaths_size(Object jarg1, long jarg2);
  public final static native int psbt_find_output_keypath(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_keypath(Object jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int psbt_get_output_keypath_len(Object jarg1, long jarg2, long jarg3);
  public final static native int psbt_get_output_unknowns_size(Object jarg1, long jarg2);
  public final static native int psbt_find_output_unknown(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_unknown(Object jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int psbt_get_output_unknown_len(Object jarg1, long jarg2, long jarg3);
  public final static native int psbt_get_output_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_script_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_amount(Object jarg1, long jarg2);
  public final static native int psbt_has_output_amount(Object jarg1, long jarg2);
  public final static native void psbt_set_output_redeem_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_set_output_witness_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_set_output_keypaths(Object jarg1, long jarg2, Object jarg3);
  public final static native void psbt_set_output_unknowns(Object jarg1, long jarg2, Object jarg3);
  public final static native void psbt_set_output_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_set_output_amount(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_clear_output_amount(Object jarg1, long jarg2);
  public final static native int psbt_get_output_blinder_index(Object jarg1, long jarg2);
  public final static native int psbt_has_output_blinder_index(Object jarg1, long jarg2);
  public final static native int psbt_get_output_value_commitment(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_value_commitment_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_asset(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_asset_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_asset_commitment(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_asset_commitment_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_value_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_value_rangeproof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_asset_surjectionproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_asset_surjectionproof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_blinding_public_key(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_blinding_public_key_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_ecdh_public_key(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_ecdh_public_key_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_value_blinding_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_value_blinding_rangeproof_len(Object jarg1, long jarg2);
  public final static native int psbt_get_output_asset_blinding_surjectionproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int psbt_get_output_asset_blinding_surjectionproof_len(Object jarg1, long jarg2);
  public final static native void psbt_set_output_blinder_index(Object jarg1, long jarg2, long jarg3);
  public final static native void psbt_clear_output_blinder_index(Object jarg1, long jarg2);
  public final static native void psbt_set_output_value_commitment(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_value_commitment(Object jarg1, long jarg2);
  public final static native void psbt_set_output_asset(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_asset(Object jarg1, long jarg2);
  public final static native void psbt_set_output_asset_commitment(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_asset_commitment(Object jarg1, long jarg2);
  public final static native void psbt_set_output_value_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_value_rangeproof(Object jarg1, long jarg2);
  public final static native void psbt_set_output_asset_surjectionproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_asset_surjectionproof(Object jarg1, long jarg2);
  public final static native void psbt_set_output_blinding_public_key(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_blinding_public_key(Object jarg1, long jarg2);
  public final static native void psbt_set_output_ecdh_public_key(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_ecdh_public_key(Object jarg1, long jarg2);
  public final static native void psbt_set_output_value_blinding_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_value_blinding_rangeproof(Object jarg1, long jarg2);
  public final static native void psbt_set_output_asset_blinding_surjectionproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void psbt_clear_output_asset_blinding_surjectionproof(Object jarg1, long jarg2);
  public final static native int psbt_get_output_blinding_status(Object jarg1, long jarg2, long jarg3);
  public final static native int scriptpubkey_get_type(byte[] jarg1);
  public final static native int scriptpubkey_p2pkh_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int scriptsig_p2pkh_from_sig(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native Object witness_p2wpkh_from_sig(byte[] jarg1, byte[] jarg3, long jarg5, long jarg6);
  public final static native int scriptsig_p2pkh_from_der(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native Object witness_p2wpkh_from_der(byte[] jarg1, byte[] jarg3, long jarg5);
  public final static native Object witness_p2tr_from_sig(byte[] jarg1, long jarg3);
  public final static native int scriptpubkey_op_return_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int scriptpubkey_p2sh_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int scriptpubkey_multisig_from_bytes(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5);
  public final static native int scriptsig_multisig_from_bytes(byte[] jarg1, byte[] jarg3, int[] jarg5, long jarg7, byte[] jarg8);
  public final static native Object witness_multisig_from_bytes(byte[] jarg1, byte[] jarg3, int[] jarg5, long jarg7, long jarg8);
  public final static native int scriptpubkey_csv_2of2_then_1_from_bytes(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5);
  public final static native int scriptpubkey_csv_2of2_then_1_from_bytes_opt(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5);
  public final static native int script_push_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int varint_get_length(long jarg1);
  public final static native int varint_to_bytes(long jarg1, byte[] jarg2);
  public final static native int varbuff_get_length(byte[] jarg1);
  public final static native int varbuff_to_bytes(byte[] jarg1, byte[] jarg3);
  public final static native int witness_program_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int witness_program_from_bytes_and_version(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5);
  public final static native int elements_pegout_script_size(long jarg1, long jarg2, long jarg3, long jarg4);
  public final static native int elements_pegout_script_from_bytes(byte[] jarg1, byte[] jarg3, byte[] jarg5, byte[] jarg7, long jarg9, byte[] jarg10);
  public final static native int elements_pegin_contract_script_from_bytes(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] symmetric_key_from_seed(byte[] jarg1, byte[] jarg3);
  public final static native byte[] symmetric_key_from_parent(byte[] jarg1, long jarg3, byte[] jarg4, byte[] jarg6);
  public final static native Object tx_witness_stack_init(long jarg1);
  public final static native Object tx_witness_stack_clone(Object jarg1);
  public final static native void tx_witness_stack_add(Object jarg1, byte[] jarg2);
  public final static native void tx_witness_stack_add_dummy(Object jarg1, long jarg2);
  public final static native void tx_witness_stack_set(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_witness_stack_set_dummy(Object jarg1, long jarg2, long jarg3);
  public final static native void tx_witness_stack_free(Object jarg1);
  public final static native Object tx_input_init(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5, Object jarg7);
  public final static native void tx_input_free(Object jarg1);
  public final static native Object tx_output_init(long jarg1, byte[] jarg2);
  public final static native Object tx_output_clone(Object jarg1);
  public final static native void tx_output_free(Object jarg1);
  public final static native Object tx_init(long jarg1, long jarg2, long jarg3, long jarg4);
  public final static native Object tx_clone(Object jarg1, long jarg2);
  public final static native void tx_add_input(Object jarg1, Object jarg2);
  public final static native void tx_add_input_at(Object jarg1, long jarg2, Object jarg3);
  public final static native void tx_add_raw_input(Object jarg1, byte[] jarg2, long jarg4, long jarg5, byte[] jarg6, Object jarg8, long jarg9);
  public final static native void tx_add_raw_input_at(Object jarg1, long jarg2, byte[] jarg3, long jarg5, long jarg6, byte[] jarg7, Object jarg9, long jarg10);
  public final static native void tx_remove_input(Object jarg1, long jarg2);
  public final static native void tx_set_input_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_input_witness(Object jarg1, long jarg2, Object jarg3);
  public final static native void tx_add_output(Object jarg1, Object jarg2);
  public final static native void tx_add_output_at(Object jarg1, long jarg2, Object jarg3);
  public final static native void tx_add_raw_output(Object jarg1, long jarg2, byte[] jarg3, long jarg5);
  public final static native void tx_add_raw_output_at(Object jarg1, long jarg2, long jarg3, byte[] jarg4, long jarg6);
  public final static native void tx_remove_output(Object jarg1, long jarg2);
  public final static native int tx_get_witness_count(Object jarg1);
  public final static native void tx_free(Object jarg1);
  public final static native byte[] tx_get_txid(Object jarg1, byte[] jarg2);
  public final static native byte[] get_hash_prevouts(byte[] jarg1, int[] jarg3, byte[] jarg5);
  public final static native byte[] tx_get_hash_prevouts(Object jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int tx_get_length(Object jarg1, long jarg2);
  public final static native Object tx_from_bytes(byte[] jarg1, long jarg3);
  public final static native Object tx_from_hex(String jarg1, long jarg2);
  public final static native int tx_to_bytes(Object jarg1, long jarg2, byte[] jarg3);
  public final static native String tx_to_hex(Object jarg1, long jarg2);
  public final static native int tx_get_weight(Object jarg1);
  public final static native int tx_get_vsize(Object jarg1);
  public final static native int tx_vsize_from_weight(long jarg1);
  public final static native long tx_get_total_output_satoshi(Object jarg1);
  public final static native byte[] tx_get_btc_signature_hash(Object jarg1, long jarg2, byte[] jarg3, long jarg5, long jarg6, long jarg7, byte[] jarg8);
  public final static native byte[] tx_get_btc_taproot_signature_hash(Object jarg1, long jarg2, Object jarg3, long[] jarg4, byte[] jarg6, long jarg8, long jarg9, byte[] jarg10, long jarg12, long jarg13, byte[] jarg14);
  public final static native byte[] tx_get_signature_hash(Object jarg1, long jarg2, byte[] jarg3, byte[] jarg5, long jarg7, long jarg8, long jarg9, long jarg10, long jarg11, byte[] jarg12);
  public final static native int _tx_is_coinbase(Object jarg1);
  public final static native void tx_elements_input_issuance_set(Object jarg1, byte[] jarg2, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10, byte[] jarg12);
  public final static native void tx_elements_input_issuance_free(Object jarg1);
  public final static native Object tx_elements_input_init(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5, Object jarg7, byte[] jarg8, byte[] jarg10, byte[] jarg12, byte[] jarg14, byte[] jarg16, byte[] jarg18, Object jarg20);
  public final static native int _tx_elements_input_is_pegin(Object jarg1);
  public final static native void tx_elements_output_commitment_set(Object jarg1, byte[] jarg2, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10);
  public final static native void tx_elements_output_commitment_free(Object jarg1);
  public final static native Object tx_elements_output_init(byte[] jarg1, byte[] jarg3, byte[] jarg5, byte[] jarg7, byte[] jarg9, byte[] jarg11);
  public final static native void tx_add_elements_raw_input(Object jarg1, byte[] jarg2, long jarg4, long jarg5, byte[] jarg6, Object jarg8, byte[] jarg9, byte[] jarg11, byte[] jarg13, byte[] jarg15, byte[] jarg17, byte[] jarg19, Object jarg21, long jarg22);
  public final static native void tx_add_elements_raw_input_at(Object jarg1, long jarg2, byte[] jarg3, long jarg5, long jarg6, byte[] jarg7, Object jarg9, byte[] jarg10, byte[] jarg12, byte[] jarg14, byte[] jarg16, byte[] jarg18, byte[] jarg20, Object jarg22, long jarg23);
  public final static native void tx_add_elements_raw_output(Object jarg1, byte[] jarg2, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10, byte[] jarg12, long jarg14);
  public final static native void tx_add_elements_raw_output_at(Object jarg1, long jarg2, byte[] jarg3, byte[] jarg5, byte[] jarg7, byte[] jarg9, byte[] jarg11, byte[] jarg13, long jarg15);
  public final static native int _tx_is_elements(Object jarg1);
  public final static native byte[] tx_confidential_value_from_satoshi(long jarg1, byte[] jarg2);
  public final static native long tx_confidential_value_to_satoshi(byte[] jarg1);
  public final static native byte[] tx_get_elements_signature_hash(Object jarg1, long jarg2, byte[] jarg3, byte[] jarg5, long jarg7, long jarg8, byte[] jarg9);
  public final static native byte[] tx_elements_issuance_generate_entropy(byte[] jarg1, long jarg3, byte[] jarg4, byte[] jarg6);
  public final static native byte[] tx_elements_issuance_calculate_asset(byte[] jarg1, byte[] jarg3);
  public final static native byte[] tx_elements_issuance_calculate_reissuance_token(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native byte[] tx_input_get_txhash(Object jarg1, byte[] jarg2);
  public final static native int _tx_input_get_script(Object jarg1, byte[] jarg2);
  public final static native int tx_input_get_script_len(Object jarg1);
  public final static native int _tx_input_get_witness(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_input_get_witness_len(Object jarg1, long jarg2);
  public final static native int tx_input_get_index(Object jarg1);
  public final static native int _tx_input_get_sequence(Object jarg1);
  public final static native void tx_input_set_txhash(Object jarg1, byte[] jarg2);
  public final static native void tx_input_set_script(Object jarg1, byte[] jarg2);
  public final static native void tx_input_set_witness(Object jarg1, Object jarg2);
  public final static native void tx_input_set_index(Object jarg1, long jarg2);
  public final static native void tx_input_set_sequence(Object jarg1, long jarg2);
  public final static native byte[] tx_input_get_blinding_nonce(Object jarg1, byte[] jarg2);
  public final static native byte[] tx_input_get_entropy(Object jarg1, byte[] jarg2);
  public final static native int _tx_input_get_issuance_amount(Object jarg1, byte[] jarg2);
  public final static native int tx_input_get_issuance_amount_len(Object jarg1);
  public final static native int _tx_input_get_inflation_keys(Object jarg1, byte[] jarg2);
  public final static native int tx_input_get_inflation_keys_len(Object jarg1);
  public final static native int _tx_input_get_issuance_amount_rangeproof(Object jarg1, byte[] jarg2);
  public final static native int tx_input_get_issuance_amount_rangeproof_len(Object jarg1);
  public final static native int _tx_input_get_inflation_keys_rangeproof(Object jarg1, byte[] jarg2);
  public final static native int tx_input_get_inflation_keys_rangeproof_len(Object jarg1);
  public final static native void tx_input_set_blinding_nonce(Object jarg1, long jarg2, long jarg3);
  public final static native void tx_input_set_entropy(Object jarg1, byte[] jarg2);
  public final static native void tx_input_set_inflation_keys(Object jarg1, byte[] jarg2);
  public final static native void tx_input_set_inflation_keys_rangeproof(Object jarg1, byte[] jarg2);
  public final static native void tx_input_set_issuance_amount(Object jarg1, byte[] jarg2);
  public final static native void tx_input_set_issuance_amount_rangeproof(Object jarg1, byte[] jarg2);
  public final static native int _tx_output_get_script(Object jarg1, byte[] jarg2);
  public final static native int tx_output_get_script_len(Object jarg1);
  public final static native long tx_output_get_satoshi(Object jarg1);
  public final static native void tx_output_set_script(Object jarg1, byte[] jarg2);
  public final static native void tx_output_set_satoshi(Object jarg1, long jarg2);
  public final static native int _tx_output_get_asset(Object jarg1, byte[] jarg2);
  public final static native int tx_output_get_asset_len(Object jarg1);
  public final static native int _tx_output_get_value(Object jarg1, byte[] jarg2);
  public final static native int tx_output_get_value_len(Object jarg1);
  public final static native int _tx_output_get_nonce(Object jarg1, byte[] jarg2);
  public final static native int tx_output_get_nonce_len(Object jarg1);
  public final static native int _tx_output_get_surjectionproof(Object jarg1, byte[] jarg2);
  public final static native int tx_output_get_surjectionproof_len(Object jarg1);
  public final static native int _tx_output_get_rangeproof(Object jarg1, byte[] jarg2);
  public final static native int tx_output_get_rangeproof_len(Object jarg1);
  public final static native void tx_output_set_asset(Object jarg1, byte[] jarg2);
  public final static native void tx_output_set_value(Object jarg1, byte[] jarg2);
  public final static native void tx_output_set_nonce(Object jarg1, byte[] jarg2);
  public final static native void tx_output_set_surjectionproof(Object jarg1, byte[] jarg2);
  public final static native void tx_output_set_rangeproof(Object jarg1, byte[] jarg2);
  public final static native int tx_get_version(Object jarg1);
  public final static native int tx_get_locktime(Object jarg1);
  public final static native int tx_get_num_inputs(Object jarg1);
  public final static native int tx_get_num_outputs(Object jarg1);
  public final static native byte[] tx_get_input_txhash(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int _tx_get_input_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_input_script_len(Object jarg1, long jarg2);
  public final static native int _tx_get_input_witness(Object jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int tx_get_input_witness_len(Object jarg1, long jarg2, long jarg3);
  public final static native int tx_get_input_index(Object jarg1, long jarg2);
  public final static native int _tx_get_input_sequence(Object jarg1, long jarg2);
  public final static native void tx_set_input_index(Object jarg1, long jarg2, long jarg3);
  public final static native void tx_set_input_sequence(Object jarg1, long jarg2, long jarg3);
  public final static native void tx_set_input_txhash(Object jarg1, long jarg2, byte[] jarg3);
  public final static native byte[] tx_get_input_blinding_nonce(Object jarg1, long jarg2, byte[] jarg3);
  public final static native byte[] tx_get_input_entropy(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int _tx_get_input_issuance_amount(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_input_issuance_amount_len(Object jarg1, long jarg2);
  public final static native int _tx_get_input_inflation_keys(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_input_inflation_keys_len(Object jarg1, long jarg2);
  public final static native int _tx_get_input_issuance_amount_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_input_issuance_amount_rangeproof_len(Object jarg1, long jarg2);
  public final static native int _tx_get_input_inflation_keys_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_input_inflation_keys_rangeproof_len(Object jarg1, long jarg2);
  public final static native void tx_set_input_blinding_nonce(Object jarg1, long jarg2, long jarg3, long jarg4);
  public final static native void tx_set_input_entropy(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_input_inflation_keys(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_input_inflation_keys_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_input_issuance_amount(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_input_issuance_amount_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int _tx_get_output_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_output_script_len(Object jarg1, long jarg2);
  public final static native long tx_get_output_satoshi(Object jarg1, long jarg2);
  public final static native void tx_set_output_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_output_satoshi(Object jarg1, long jarg2, long jarg3);
  public final static native byte[] tx_get_output_asset(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int _tx_get_output_value(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_output_value_len(Object jarg1, long jarg2);
  public final static native byte[] tx_get_output_nonce(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int _tx_get_output_surjectionproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_output_surjectionproof_len(Object jarg1, long jarg2);
  public final static native int _tx_get_output_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_output_rangeproof_len(Object jarg1, long jarg2);
  public final static native void tx_set_output_asset(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_output_value(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_output_nonce(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_output_surjectionproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_output_rangeproof(Object jarg1, long jarg2, byte[] jarg3);
  public final static native byte[] asset_generator_from_bytes(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] ecdh_nonce_hash(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] asset_final_vbf(long[] jarg1, long jarg3, byte[] jarg4, byte[] jarg6, byte[] jarg8);
  public final static native byte[] asset_scalar_offset(long jarg1, byte[] jarg2, byte[] jarg4, byte[] jarg6);
  public final static native byte[] asset_value_commitment(long jarg1, byte[] jarg2, byte[] jarg4, byte[] jarg6);
  public final static native int asset_rangeproof_get_maximum_len(long jarg1, int jarg2);
  public final static native int asset_rangeproof_with_nonce(long jarg1, byte[] jarg2, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10, byte[] jarg12, byte[] jarg14, long jarg16, int jarg17, int jarg18, byte[] jarg19);
  public final static native int asset_rangeproof(long jarg1, byte[] jarg2, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10, byte[] jarg12, byte[] jarg14, byte[] jarg16, long jarg18, int jarg19, int jarg20, byte[] jarg21);
  public final static native int explicit_rangeproof(long jarg1, byte[] jarg2, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10);
  public final static native void explicit_rangeproof_verify(byte[] jarg1, long jarg3, byte[] jarg4, byte[] jarg6);
  public final static native int asset_surjectionproof_size(long jarg1);
  public final static native int asset_surjectionproof_len(byte[] jarg1, byte[] jarg3, byte[] jarg5, byte[] jarg7, byte[] jarg9, byte[] jarg11, byte[] jarg13);
  public final static native int asset_surjectionproof(byte[] jarg1, byte[] jarg3, byte[] jarg5, byte[] jarg7, byte[] jarg9, byte[] jarg11, byte[] jarg13, byte[] jarg15);
  public final static native byte[] explicit_surjectionproof(byte[] jarg1, byte[] jarg3, byte[] jarg5, byte[] jarg7);
  public final static native void explicit_surjectionproof_verify(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native long asset_unblind_with_nonce(byte[] jarg1, byte[] jarg3, byte[] jarg5, byte[] jarg7, byte[] jarg9, byte[] jarg11, byte[] jarg13, byte[] jarg15);
  public final static native long asset_unblind(byte[] jarg1, byte[] jarg3, byte[] jarg5, byte[] jarg7, byte[] jarg9, byte[] jarg11, byte[] jarg13, byte[] jarg15, byte[] jarg17);
  public final static native byte[] asset_blinding_key_from_seed(byte[] jarg1, byte[] jarg3);
  public final static native byte[] asset_blinding_key_to_ec_private_key(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] asset_blinding_key_to_abf_vbf(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] asset_blinding_key_to_abf(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] asset_blinding_key_to_vbf(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native int asset_pak_whitelistproof_size(long jarg1);
  public final static native int asset_pak_whitelistproof(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6, byte[] jarg8, byte[] jarg10, byte[] jarg12);
  public final static native int asset_pak_whitelistproof_len(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6, byte[] jarg8, byte[] jarg10);
  public final static int WALLY_OK = 0;
  public final static int WALLY_ERROR = -1;
  public final static int WALLY_EINVAL = -2;
  public final static int WALLY_ENOMEM = -3;
  public final static int WALLY_SECP_RANDOMIZE_LEN = 32;
  public final static int BASE58_FLAG_CHECKSUM = 0x1;
  public final static int BASE58_CHECKSUM_LEN = 4;
  public final static int WALLY_WIF_FLAG_COMPRESSED = 0x0;
  public final static int WALLY_WIF_FLAG_UNCOMPRESSED = 0x1;
  public final static int WALLY_CA_PREFIX_LIQUID = 0x0c;
  public final static int WALLY_CA_PREFIX_LIQUID_REGTEST = 0x04;
  public final static int WALLY_CA_PREFIX_LIQUID_TESTNET = 0x17;
  public final static int WALLY_NETWORK_NONE = 0x00;
  public final static int WALLY_NETWORK_BITCOIN_MAINNET = 0x01;
  public final static int WALLY_NETWORK_BITCOIN_REGTEST = 0xff;
  public final static int WALLY_NETWORK_BITCOIN_TESTNET = 0x02;
  public final static int WALLY_NETWORK_LIQUID = 0x03;
  public final static int WALLY_NETWORK_LIQUID_REGTEST = 0x04;
  public final static int WALLY_NETWORK_LIQUID_TESTNET = 0x05;
  public final static int WALLY_ADDRESS_TYPE_P2PKH = 0x01;
  public final static int WALLY_ADDRESS_TYPE_P2SH_P2WPKH = 0x02;
  public final static int WALLY_ADDRESS_TYPE_P2WPKH = 0x04;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_MAINNET = 0x00;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_TESTNET = 0x6F;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_LIQUID = 0x39;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_LIQUID_REGTEST = 0xEB;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_LIQUID_TESTNET = 0x24;
  public final static int WALLY_ADDRESS_VERSION_P2SH_MAINNET = 0x05;
  public final static int WALLY_ADDRESS_VERSION_P2SH_TESTNET = 0xC4;
  public final static int WALLY_ADDRESS_VERSION_P2SH_LIQUID = 0x27;
  public final static int WALLY_ADDRESS_VERSION_P2SH_LIQUID_REGTEST = 0x4B;
  public final static int WALLY_ADDRESS_VERSION_P2SH_LIQUID_TESTNET = 0x13;
  public final static int WALLY_ADDRESS_VERSION_WIF_MAINNET = 0x80;
  public final static int WALLY_ADDRESS_VERSION_WIF_TESTNET = 0xEF;
  public final static int WALLY_SEGWIT_ADDRESS_PUBKEY_MAX_LEN = 42;
  public final static int WALLY_ADDRESS_PUBKEY_MAX_LEN = 25;
  public final static int WALLY_SEGWIT_V0_ADDRESS_PUBKEY_MAX_LEN = 34;
  public final static int WALLY_SEGWIT_V1_ADDRESS_PUBKEY_LEN = 34;
  public final static int WALLY_HOST_COMMITMENT_LEN = 32;
  public final static int BIP32_ENTROPY_LEN_128 = 16;
  public final static int BIP32_ENTROPY_LEN_256 = 32;
  public final static int BIP32_ENTROPY_LEN_512 = 64;
  public final static int BIP32_KEY_FINGERPRINT_LEN = 4;
  public final static int BIP32_SERIALIZED_LEN = 78;
  public final static int BIP32_INITIAL_HARDENED_CHILD = 0x80000000;
  public final static int BIP32_PATH_MAX_LEN = 255;
  public final static int WALLY_BIP32_CHAIN_CODE_LEN = 32;
  public final static int WALLY_BIP32_TWEAK_SUM_LEN = 32;
  public final static int BIP32_FLAG_KEY_PRIVATE = 0x0;
  public final static int BIP32_FLAG_KEY_PUBLIC = 0x1;
  public final static int BIP32_FLAG_SKIP_HASH = 0x2;
  public final static int BIP32_FLAG_KEY_TWEAK_SUM = 0x4;
  public final static int BIP32_FLAG_STR_WILDCARD = 0x8;
  public final static int BIP32_FLAG_STR_BARE = 0x10;
  public final static int BIP32_FLAG_ALLOW_UPPER = 0x20;
  public final static int BIP32_FLAG_STR_MULTIPATH = 0x40;
  public final static int BIP32_VER_MAIN_PUBLIC = 0x0488B21E;
  public final static int BIP32_VER_MAIN_PRIVATE = 0x0488ADE4;
  public final static int BIP32_VER_TEST_PUBLIC = 0x043587CF;
  public final static int BIP32_VER_TEST_PRIVATE = 0x04358394;
  public final static int BIP32_PATH_LEN_MASK = 0x000000ff;
  public final static int BIP32_PATH_LEN_SHIFT = 0x00000000;
  public final static int BIP32_PATH_MULTI_MASK = 0x0000ff00;
  public final static int BIP32_PATH_MULTI_SHIFT = 0x00000008;
  public final static int BIP32_PATH_WILDCARD_MASK = 0x00ff0000;
  public final static int BIP32_PATH_WILDCARD_SHIFT = 0x00000010;
  public final static int BIP32_PATH_IS_BARE = 0x01000000;
  public final static int BIP32_PATH_IS_HARDENED = 0x02000000;
  public final static int BIP32_PATH_IS_WILDCARD = 0x04000000;
  public final static int BIP32_PATH_IS_MULTIPATH = 0x08000000;
  public final static int LIBWALLY_CORE_BIP32_INT_H = 1;
  public final static int BIP38_KEY_NETWORK_MASK = 0xff;
  public final static int BIP38_KEY_MAINNET = 0;
  public final static int BIP38_KEY_TESTNET = 111;
  public final static int BIP38_KEY_COMPRESSED = 256;
  public final static int BIP38_KEY_EC_MULT = 512;
  public final static int BIP38_KEY_QUICK_CHECK = 1024;
  public final static int BIP38_KEY_RAW_MODE = 2048;
  public final static int BIP38_KEY_SWAP_ORDER = 4096;
  public final static int BIP38_SERIALIZED_LEN = 39;
  public final static int BIP39_ENTROPY_LEN_128 = 16;
  public final static int BIP39_ENTROPY_LEN_160 = 20;
  public final static int BIP39_ENTROPY_LEN_192 = 24;
  public final static int BIP39_ENTROPY_LEN_224 = 28;
  public final static int BIP39_ENTROPY_LEN_256 = 32;
  public final static int BIP39_ENTROPY_LEN_288 = 36;
  public final static int BIP39_ENTROPY_LEN_320 = 40;
  public final static int BIP39_SEED_LEN_512 = 64;
  public final static int BIP39_ENTROPY_MAX_LEN = 42;
  public final static int BIP39_WORDLIST_LEN = 2048;
  public final static int WALLY_CS_MAX_ASSETS = 256;
  public final static int AES_BLOCK_LEN = 16;
  public final static int AES_KEY_LEN_128 = 16;
  public final static int AES_KEY_LEN_192 = 24;
  public final static int AES_KEY_LEN_256 = 32;
  public final static int AES_FLAG_ENCRYPT = 1;
  public final static int AES_FLAG_DECRYPT = 2;
  public final static int SHA256_LEN = 32;
  public final static int SHA512_LEN = 64;
  public final static int RIPEMD160_LEN = 20;
  public final static int HASH160_LEN = 20;
  public final static int HMAC_SHA256_LEN = 32;
  public final static int HMAC_SHA512_LEN = 64;
  public final static int PBKDF2_HMAC_SHA256_LEN = 32;
  public final static int PBKDF2_HMAC_SHA512_LEN = 64;
  public final static int EC_PRIVATE_KEY_LEN = 32;
  public final static int EC_PUBLIC_KEY_LEN = 33;
  public final static int EC_XONLY_PUBLIC_KEY_LEN = 32;
  public final static int EC_PUBLIC_KEY_UNCOMPRESSED_LEN = 65;
  public final static int EC_MESSAGE_HASH_LEN = 32;
  public final static int EC_SIGNATURE_LEN = 64;
  public final static int EC_SIGNATURE_RECOVERABLE_LEN = 65;
  public final static int EC_SIGNATURE_DER_MAX_LEN = 72;
  public final static int EC_SIGNATURE_DER_MAX_LOW_R_LEN = 71;
  public final static int EC_SCALAR_LEN = 32;
  public final static int EC_FLAG_ECDSA = 0x1;
  public final static int EC_FLAG_SCHNORR = 0x2;
  public final static int EC_FLAG_GRIND_R = 0x4;
  public final static int EC_FLAG_RECOVERABLE = 0x8;
  public final static int EC_FLAG_ELEMENTS = 0x10;
  public final static int EC_FLAGS_ALL = (0x1|0x2|0x4|0x8);
  public final static int BITCOIN_MESSAGE_MAX_LEN = (64*1024-64);
  public final static int BITCOIN_MESSAGE_FLAG_HASH = 1;
  public final static int WALLY_S2C_DATA_LEN = 32;
  public final static int WALLY_S2C_OPENING_LEN = 33;
  public final static int WALLY_MINISCRIPT_TAPSCRIPT = 0x01;
  public final static int WALLY_MINISCRIPT_ONLY = 0x02;
  public final static int WALLY_MINISCRIPT_REQUIRE_CHECKSUM = 0x04;
  public final static int WALLY_MINISCRIPT_DEPTH_MASK = 0xffff0000;
  public final static int WALLY_MINISCRIPT_DEPTH_SHIFT = 16;
  public final static int WALLY_MS_IS_RANGED = 0x01;
  public final static int WALLY_MS_IS_MULTIPATH = 0x02;
  public final static int WALLY_MS_IS_PRIVATE = 0x04;
  public final static int WALLY_MS_IS_UNCOMPRESSED = 0x08;
  public final static int WALLY_MS_IS_RAW = 0x10;
  public final static int WALLY_MS_IS_DESCRIPTOR = 0x20;
  public final static int WALLY_MS_CANONICAL_NO_CHECKSUM = 0x01;
  public final static int WALLY_PSBT_VERSION_0 = 0x0;
  public final static int WALLY_PSBT_VERSION_2 = 0x2;
  public final static int WALLY_PSBT_HIGHEST_VERSION = 0x2;
  public final static int WALLY_PSBT_INIT_PSET = 0x1;
  public final static int WALLY_PSBT_FLAG_NON_FINAL = 0x1;
  public final static int WALLY_PSBT_PROPRIETARY_TYPE = 0xFC;
  public final static int WALLY_PSBT_TXMOD_INPUTS = 0x1;
  public final static int WALLY_PSBT_TXMOD_OUTPUTS = 0x2;
  public final static int WALLY_PSBT_TXMOD_SINGLE = 0x4;
  public final static int WALLY_PSET_TXMOD_RESERVED = 0x1;
  public final static int WALLY_PSBT_PARSE_FLAG_STRICT = 0x1;
  public final static int WALLY_PSBT_SERIALIZE_FLAG_REDUNDANT = 0x1;
  public final static int WALLY_PSBT_EXTRACT_NON_FINAL = 0x1;
  public final static int WALLY_PSBT_FINALIZE_NO_CLEAR = 0x1;
  public final static int WALLY_PSBT_ID_BIP370 = 0x0;
  public final static int WALLY_PSBT_ID_AS_V2 = 0x1;
  public final static int WALLY_PSBT_ID_USE_LOCKTIME = 0x2;
  public final static int WALLY_PSET_BLINDED_NONE = 0x0;
  public final static int WALLY_PSET_BLINDED_REQUIRED = 0x1;
  public final static int WALLY_PSET_BLINDED_PARTIAL = 0x2;
  public final static int WALLY_PSET_BLINDED_FULL = 0x4;
  public final static int WALLY_PSET_BLIND_ALL = 0xffffffff;
  public final static int WALLY_SCALAR_OFFSET_LEN = 32;
  public final static int LIBWALLY_CORE_PSBT_MEMBERS_H = 1;
  public final static int WALLY_SCRIPT_TYPE_UNKNOWN = 0x0;
  public final static int WALLY_SCRIPT_TYPE_OP_RETURN = 0x1;
  public final static int WALLY_SCRIPT_TYPE_P2PKH = 0x2;
  public final static int WALLY_SCRIPT_TYPE_P2SH = 0x4;
  public final static int WALLY_SCRIPT_TYPE_P2WPKH = 0x8;
  public final static int WALLY_SCRIPT_TYPE_P2WSH = 0x10;
  public final static int WALLY_SCRIPT_TYPE_MULTISIG = 0x20;
  public final static int WALLY_SCRIPT_TYPE_P2TR = 0x40;
  public final static int WALLY_SCRIPT_TYPE_CSV2OF2_1 = 0x80;
  public final static int WALLY_SCRIPT_TYPE_CSV2OF2_1_OPT = 0x81;
  public final static int WALLY_SCRIPTPUBKEY_P2PKH_LEN = 25;
  public final static int WALLY_SCRIPTPUBKEY_P2SH_LEN = 23;
  public final static int WALLY_SCRIPTPUBKEY_P2WPKH_LEN = 22;
  public final static int WALLY_SCRIPTPUBKEY_P2WSH_LEN = 34;
  public final static int WALLY_SCRIPTPUBKEY_P2TR_LEN = 34;
  public final static int WALLY_SCRIPTPUBKEY_OP_RETURN_MAX_LEN = 83;
  public final static int WALLY_MAX_OP_RETURN_LEN = 80;
  public final static int WALLY_SCRIPTSIG_P2PKH_MAX_LEN = 140;
  public final static int WALLY_SCRIPTSIG_MAX_LEN = 520;
  public final static int WALLY_WITNESSSCRIPT_MAX_LEN = 42;
  public final static int WALLY_SCRIPT_VARINT_MAX_SIZE = 9;
  public final static int WALLY_SCRIPT_HASH160 = 0x1;
  public final static int WALLY_SCRIPT_SHA256 = 0x2;
  public final static int WALLY_SCRIPT_AS_PUSH = 0x4;
  public final static int WALLY_SCRIPT_MULTISIG_SORTED = 0x8;
  public final static int OP_0 = 0x00;
  public final static int OP_FALSE = 0x00;
  public final static int OP_PUSHDATA1 = 0x4c;
  public final static int OP_PUSHDATA2 = 0x4d;
  public final static int OP_PUSHDATA4 = 0x4e;
  public final static int OP_1NEGATE = 0x4f;
  public final static int OP_RESERVED = 0x50;
  public final static int OP_1 = 0x51;
  public final static int OP_TRUE = 0x51;
  public final static int OP_2 = 0x52;
  public final static int OP_3 = 0x53;
  public final static int OP_4 = 0x54;
  public final static int OP_5 = 0x55;
  public final static int OP_6 = 0x56;
  public final static int OP_7 = 0x57;
  public final static int OP_8 = 0x58;
  public final static int OP_9 = 0x59;
  public final static int OP_10 = 0x5a;
  public final static int OP_11 = 0x5b;
  public final static int OP_12 = 0x5c;
  public final static int OP_13 = 0x5d;
  public final static int OP_14 = 0x5e;
  public final static int OP_15 = 0x5f;
  public final static int OP_16 = 0x60;
  public final static int OP_NOP = 0x61;
  public final static int OP_VER = 0x62;
  public final static int OP_IF = 0x63;
  public final static int OP_NOTIF = 0x64;
  public final static int OP_VERIF = 0x65;
  public final static int OP_VERNOTIF = 0x66;
  public final static int OP_ELSE = 0x67;
  public final static int OP_ENDIF = 0x68;
  public final static int OP_VERIFY = 0x69;
  public final static int OP_RETURN = 0x6a;
  public final static int OP_TOALTSTACK = 0x6b;
  public final static int OP_FROMALTSTACK = 0x6c;
  public final static int OP_2DROP = 0x6d;
  public final static int OP_2DUP = 0x6e;
  public final static int OP_3DUP = 0x6f;
  public final static int OP_2OVER = 0x70;
  public final static int OP_2ROT = 0x71;
  public final static int OP_2SWAP = 0x72;
  public final static int OP_IFDUP = 0x73;
  public final static int OP_DEPTH = 0x74;
  public final static int OP_DROP = 0x75;
  public final static int OP_DUP = 0x76;
  public final static int OP_NIP = 0x77;
  public final static int OP_OVER = 0x78;
  public final static int OP_PICK = 0x79;
  public final static int OP_ROLL = 0x7a;
  public final static int OP_ROT = 0x7b;
  public final static int OP_SWAP = 0x7c;
  public final static int OP_TUCK = 0x7d;
  public final static int OP_CAT = 0x7e;
  public final static int OP_SUBSTR = 0x7f;
  public final static int OP_LEFT = 0x80;
  public final static int OP_RIGHT = 0x81;
  public final static int OP_SIZE = 0x82;
  public final static int OP_INVERT = 0x83;
  public final static int OP_AND = 0x84;
  public final static int OP_OR = 0x85;
  public final static int OP_XOR = 0x86;
  public final static int OP_EQUAL = 0x87;
  public final static int OP_EQUALVERIFY = 0x88;
  public final static int OP_RESERVED1 = 0x89;
  public final static int OP_RESERVED2 = 0x8a;
  public final static int OP_1ADD = 0x8b;
  public final static int OP_1SUB = 0x8c;
  public final static int OP_2MUL = 0x8d;
  public final static int OP_2DIV = 0x8e;
  public final static int OP_NEGATE = 0x8f;
  public final static int OP_ABS = 0x90;
  public final static int OP_NOT = 0x91;
  public final static int OP_0NOTEQUAL = 0x92;
  public final static int OP_ADD = 0x93;
  public final static int OP_SUB = 0x94;
  public final static int OP_MUL = 0x95;
  public final static int OP_DIV = 0x96;
  public final static int OP_MOD = 0x97;
  public final static int OP_LSHIFT = 0x98;
  public final static int OP_RSHIFT = 0x99;
  public final static int OP_BOOLAND = 0x9a;
  public final static int OP_BOOLOR = 0x9b;
  public final static int OP_NUMEQUAL = 0x9c;
  public final static int OP_NUMEQUALVERIFY = 0x9d;
  public final static int OP_NUMNOTEQUAL = 0x9e;
  public final static int OP_LESSTHAN = 0x9f;
  public final static int OP_GREATERTHAN = 0xa0;
  public final static int OP_LESSTHANOREQUAL = 0xa1;
  public final static int OP_GREATERTHANOREQUAL = 0xa2;
  public final static int OP_MIN = 0xa3;
  public final static int OP_MAX = 0xa4;
  public final static int OP_WITHIN = 0xa5;
  public final static int OP_RIPEMD160 = 0xa6;
  public final static int OP_SHA1 = 0xa7;
  public final static int OP_SHA256 = 0xa8;
  public final static int OP_HASH160 = 0xa9;
  public final static int OP_HASH256 = 0xaa;
  public final static int OP_CODESEPARATOR = 0xab;
  public final static int OP_CHECKSIG = 0xac;
  public final static int OP_CHECKSIGVERIFY = 0xad;
  public final static int OP_CHECKMULTISIG = 0xae;
  public final static int OP_CHECKMULTISIGVERIFY = 0xaf;
  public final static int OP_NOP1 = 0xb0;
  public final static int OP_CHECKLOCKTIMEVERIFY = 0xb1;
  public final static int OP_NOP2 = 0xb1;
  public final static int OP_CHECKSEQUENCEVERIFY = 0xb2;
  public final static int OP_NOP3 = 0xb2;
  public final static int OP_NOP4 = 0xb3;
  public final static int OP_NOP5 = 0xb4;
  public final static int OP_NOP6 = 0xb5;
  public final static int OP_NOP7 = 0xb6;
  public final static int OP_NOP8 = 0xb7;
  public final static int OP_NOP9 = 0xb8;
  public final static int OP_NOP10 = 0xb9;
  public final static int OP_INVALIDOPCODE = 0xff;
  public final static int WALLY_TX_SEQUENCE_FINAL = 0xffffffff;
  public final static int WALLY_TX_VERSION_1 = 1;
  public final static int WALLY_TX_VERSION_2 = 2;
  public final static int WALLY_TX_IS_ELEMENTS = 1;
  public final static int WALLY_TX_IS_ISSUANCE = 2;
  public final static int WALLY_TX_IS_PEGIN = 4;
  public final static int WALLY_TX_IS_COINBASE = 8;
  public final static int WALLY_SATOSHI_PER_BTC = 100000000;
  public final static int WALLY_BTC_MAX = 21000000;
  public final static int WALLY_TXHASH_LEN = 32;
  public final static int WALLY_TX_FLAG_USE_WITNESS = 0x1;
  public final static int WALLY_TX_FLAG_USE_ELEMENTS = 0x2;
  public final static int WALLY_TX_FLAG_ALLOW_PARTIAL = 0x4;
  public final static int WALLY_TX_FLAG_PRE_BIP144 = 0x8;
  public final static int WALLY_TX_FLAG_BLINDED_INITIAL_ISSUANCE = 0x1;
  public final static int WALLY_TX_DUMMY_NULL = 0x1;
  public final static int WALLY_TX_DUMMY_SIG = 0x2;
  public final static int WALLY_TX_DUMMY_SIG_LOW_R = 0x4;
  public final static int WALLY_SIGHASH_DEFAULT = 0x00;
  public final static int WALLY_SIGHASH_ALL = 0x01;
  public final static int WALLY_SIGHASH_NONE = 0x02;
  public final static int WALLY_SIGHASH_SINGLE = 0x03;
  public final static int WALLY_SIGHASH_FORKID = 0x40;
  public final static int WALLY_SIGHASH_RANGEPROOF = 0x40;
  public final static int WALLY_SIGHASH_ANYPREVOUT = 0x40;
  public final static int WALLY_SIGHASH_ANYPREVOUTANYSCRIPT = 0xc0;
  public final static int WALLY_SIGHASH_ANYONECANPAY = 0x80;
  public final static int WALLY_SIGHASH_MASK = 0x1f;
  public final static int WALLY_SIGHASH_TR_IN_MASK = 0xc0;
  public final static int WALLY_TX_ASSET_CT_EMPTY_PREFIX = 0x00;
  public final static int WALLY_TX_ASSET_CT_EXPLICIT_PREFIX = 0x01;
  public final static int WALLY_TX_ASSET_CT_VALUE_PREFIX_A = 0x08;
  public final static int WALLY_TX_ASSET_CT_VALUE_PREFIX_B = 0x09;
  public final static int WALLY_TX_ASSET_CT_ASSET_PREFIX_A = 0x0a;
  public final static int WALLY_TX_ASSET_CT_ASSET_PREFIX_B = 0x0b;
  public final static int WALLY_TX_ASSET_CT_NONCE_PREFIX_A = 0x02;
  public final static int WALLY_TX_ASSET_CT_NONCE_PREFIX_B = 0x03;
  public final static int WALLY_TX_ASSET_TAG_LEN = 32;
  public final static int WALLY_TX_ASSET_CT_VALUE_LEN = 33;
  public final static int WALLY_TX_ASSET_CT_VALUE_UNBLIND_LEN = 9;
  public final static int WALLY_TX_ASSET_CT_ASSET_LEN = 33;
  public final static int WALLY_TX_ASSET_CT_NONCE_LEN = 33;
  public final static int WALLY_TX_ASSET_CT_LEN = 33;
  public final static int WALLY_TX_ISSUANCE_FLAG = 0x80000000;
  public final static int WALLY_TX_PEGIN_FLAG = 0x40000000;
  public final static int WALLY_TX_INDEX_MASK = 0x3fffffff;
  public final static int WALLY_NO_CODESEPARATOR = 0xffffffff;
  public final static int LIBWALLY_CORE_TRANSACTION_INT_H = 1;
  public final static int ASSET_TAG_LEN = 32;
  public final static int BLINDING_FACTOR_LEN = 32;
  public final static int ASSET_GENERATOR_LEN = 33;
  public final static int ASSET_COMMITMENT_LEN = 33;
  public final static int ASSET_RANGEPROOF_MAX_LEN = 5134;
  public final static int ASSET_EXPLICIT_RANGEPROOF_MAX_LEN = 73;
  public final static int ASSET_SURJECTIONPROOF_MAX_LEN = 162;
  public final static int ASSET_EXPLICIT_SURJECTIONPROOF_LEN = 67;
  public final static int WALLY_ABF_VBF_LEN = 64;

  // Support methods for the JNI class

  private final static byte[] trimBuffer(final byte[] buf, final int len) {
      if (len > buf.length) throw new IllegalArgumentException();
      return len == buf.length ? buf: java.util.Arrays.copyOf(buf, len);
  }

  private final static byte[] checkBuffer(final byte[] buf, final int len) {
      if (len != buf.length)
          throw new RuntimeException("Failed");
      return buf;
  }

  private final static int[] trimIntBuffer(final int[] buf, final int len) {
      if (len > buf.length) throw new IllegalArgumentException();
      return len == buf.length ? buf: java.util.Arrays.copyOf(buf, len);
  }

  private final static int[] checkIntBuffer(final int[] buf, final int len) {
      if (len != buf.length)
          throw new RuntimeException("Failed");
      return buf;
  }

  private final static byte[] get_keypath_fingerprint(final byte[] buf) {
      if (buf.length == 0) return buf;
      final byte[] ret = new byte[4];
      ret[0] = buf[0]; ret[1] = buf[1]; ret[2] = buf[2]; ret[3] = buf[3];
      return ret;
  }

  public final static byte[] aes(byte[] jarg1, byte[] jarg2, long jarg3) {
      return aes(jarg1, jarg2, jarg3, null);
  }

  public final static String base58check_from_bytes(byte[] bytes) {
      return base58_from_bytes(bytes, BASE58_FLAG_CHECKSUM);
  }

  private final static byte[] base58_to_bytes(String base58, long flags) {
      final byte buf[] = new byte[base58_get_length(base58)];
      final int len = base58_to_bytes(base58, flags, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] base58_to_bytes(String base58) {
      return base58_to_bytes(base58, 0);
  }

  public final static byte[] base58check_to_bytes(String base58) {
      return base58_to_bytes(base58, BASE58_FLAG_CHECKSUM);
  }

  private final static byte[] base64_to_bytes(String base64, long flags) {
      final byte buf[] = new byte[base64_get_maximum_length(base64, flags)];
      final int len = base64_to_bytes(base64, flags, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] bip39_mnemonic_to_seed512(String mnemonic, String passphrase) {
      return bip39_mnemonic_to_seed512(mnemonic, passphrase, null);
  }

  public final static byte[] base64_to_bytes(String base64) {
      return base64_to_bytes(base64, 0);
  }

  public final static Object bip32_pub_key_init(final int version, final int depth, final int childNum,
                                         final byte[] chainCode, final byte[] pubKey) {
      return Wally.bip32_key_init(version, depth, childNum, chainCode, pubKey, null, null, null);
  }

  public final static Object bip32_priv_key_init(final int version, final int depth, final int childNum,
                                                 final byte[] chainCode, final byte[] privateKey) {
      return Wally.bip32_key_init(version, depth, childNum, chainCode, null, privateKey, null, null);
  }

  public final static byte[] bip32_key_get_chain_code(Object jarg1) {
      return bip32_key_get_chain_code(jarg1, null);
  }

  public final static byte[] bip32_key_get_parent160(Object jarg1) {
      return bip32_key_get_parent160(jarg1, null);
  }

  public final static byte[] bip32_key_get_priv_key(Object jarg1) {
      return bip32_key_get_priv_key(jarg1, null);
  }

  public final static byte[] bip32_key_get_fingerprint(Object jarg1) {
      return bip32_key_get_fingerprint(jarg1, null);
  }

  public final static byte[] bip32_key_get_hash160(Object jarg1) {
      return bip32_key_get_hash160(jarg1, null);
  }

  public final static byte[] bip32_key_get_pub_key(Object jarg1) {
      return bip32_key_get_pub_key(jarg1, null);
  }

  public final static byte[] bip32_key_serialize(Object jarg1, long jarg2) {
      return bip32_key_serialize(jarg1, jarg2, null);
  }

  public final static byte[] bip38_raw_from_private_key(byte[] jarg1, byte[] jarg2, long jarg3) {
      return bip38_raw_from_private_key(jarg1, jarg2, jarg3, null);
  }

  public final static byte[] bip38_to_private_key(String jarg1, byte[] jarg2, long jarg3) {
      return bip38_to_private_key(jarg1, jarg2, jarg3, null);
  }

  public final static byte[] bip85_get_bip39_entropy(Object hdkey, String lang, long num_words, long index) {
      final byte[] buf = new byte[HMAC_SHA512_LEN];
      final int len = bip85_get_bip39_entropy(hdkey, lang, num_words, index, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] ecdh(byte[] jarg1, byte[] jarg2) {
      return ecdh(jarg1, jarg2, null);
  }

  public final static byte[] sha256(byte[] jarg1) {
      return sha256(jarg1, null);
  }

  public final static byte[] sha256d(byte[] jarg1) {
      return sha256d(jarg1, null);
  }

  public final static byte[] sha512(byte[] jarg1) {
      return sha512(jarg1, null);
  }

  public final static byte[] hash160(byte[] jarg1) {
      return hash160(jarg1, null);
  }

  public final static byte[] hex_to_bytes(String jarg1) {
      final byte[] ret = new byte[jarg1.length() / 2];
      if (hex_to_bytes(jarg1, ret) != ret.length)
          throw new IllegalArgumentException("invalid hex string length");
      return ret;
  }

  public final static byte[] hmac_sha256(byte[] jarg1, byte[] jarg2) {
      return hmac_sha256(jarg1, jarg2, null);
  }

  public final static byte[] hmac_sha512(byte[] jarg1, byte[] jarg2) {
      return hmac_sha512(jarg1, jarg2, null);
  }

  public final static byte[] pbkdf2_hmac_sha256(byte[] jarg1, byte[] jarg2, long jarg3, long jarg4) {
      return pbkdf2_hmac_sha256(jarg1, jarg2, jarg3, jarg4, null);
  }

  public final static byte[] pbkdf2_hmac_sha512(byte[] jarg1, byte[] jarg2, long jarg3, long jarg4) {
      return pbkdf2_hmac_sha512(jarg1, jarg2, jarg3, jarg4, null);
  }

  public final static byte[] ec_public_key_from_private_key(byte[] jarg1) {
      return ec_public_key_from_private_key(jarg1, null);
  }

  public final static byte[] ec_public_key_negate(byte[] jarg1) {
      return ec_public_key_negate(jarg1, null);
  }

  public final static byte[] ec_sig_from_bytes(byte[] jarg1, byte[] jarg2, long jarg3) {
      return ec_sig_from_bytes(jarg1, jarg2, jarg3, null);
  }

  public final static byte[] ec_sig_from_bytes_aux(byte[] jarg1, byte[] jarg2, byte[] jarg3, long jarg4) {
      return ec_sig_from_bytes_aux(jarg1, jarg2, jarg3, jarg4, null);
  }

  public final static byte[] ec_sig_normalize(byte[] jarg1) {
      return ec_sig_normalize(jarg1, null);
  }

  public final static byte[] ec_sig_from_der(byte[] jarg1) {
      return ec_sig_from_der(jarg1, null);
  }

  public final static byte[] ec_sig_to_public_key(byte[] jarg1, byte[] jarg2) {
      return ec_sig_to_public_key(jarg1, jarg2, null);
  }

  public final static byte[] ec_scalar_add(byte[] jarg1, byte[] jarg2) {
      return ec_scalar_add(jarg1, jarg2, null);
  }

  public final static byte[] ec_scalar_multiply(byte[] jarg1, byte[] jarg2) {
      return ec_scalar_multiply(jarg1, jarg2, null);
  }

  public final static byte[] ec_scalar_subtract(byte[] jarg1, byte[] jarg2) {
      return ec_scalar_subtract(jarg1, jarg2, null);
  }

  public final static byte[] tx_get_input_txhash(Object jarg1, long jarg2) {
        return tx_get_input_txhash(jarg1, jarg2, null);
  }

  public final static byte[] tx_input_get_txhash(Object jarg1) {
        return tx_input_get_txhash(jarg1, null);
  }

  public final static byte[] ec_sig_to_der(byte[] sig) {
      final byte[] buf = new byte[EC_SIGNATURE_DER_MAX_LEN];
      final int len = ec_sig_to_der(sig, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] format_bitcoin_message(byte[] jarg1, long jarg2) {
      int msg_len = SHA256_LEN;
      if ((jarg2 & BITCOIN_MESSAGE_FLAG_HASH) == 0)
          msg_len = 25 + jarg1.length + (jarg1.length < 253 ? 1 : 3);
      final byte[] ret = new byte[msg_len];
      if (format_bitcoin_message(jarg1, jarg2, ret) != ret.length)
          throw new IllegalArgumentException("Invalid formatted message");
      return ret;
  }

  private final static byte[] _get_push_buf(final int in_buf_len, final int extra_bytes) {
      int len = 5;
      if (in_buf_len < 76)
          len = 1;
      else if (in_buf_len < 256)
          len = 2;
      else if (in_buf_len < 65536)
          len = 3;

      return new byte[len + in_buf_len + extra_bytes];
  }

  public final static byte[] script_push_from_bytes(byte[] jarg1, long flags) {
      final byte[] ret = _get_push_buf(jarg1.length, 0);
      if (script_push_from_bytes(jarg1, flags, ret) != ret.length)
          throw new IllegalArgumentException("Error encoding push");
      return ret;
  }

  public final static byte[] scriptpubkey_p2pkh_from_bytes(byte[] bytes, long flags) {
      final byte[] buf = new byte[WALLY_SCRIPTPUBKEY_P2PKH_LEN];
      final int len = scriptpubkey_p2pkh_from_bytes(bytes, flags, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] scriptpubkey_p2sh_from_bytes(byte[] bytes, long flags) {
      final byte[] buf = new byte[WALLY_SCRIPTPUBKEY_P2SH_LEN];
      final int len = scriptpubkey_p2sh_from_bytes(bytes, flags, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] scriptpubkey_multisig_from_bytes(byte[] bytes, long threshold, long flags, int num_sigs) {
      final int required_len = 3 + num_sigs * (Wally.EC_PUBLIC_KEY_LEN + 1);
      final byte[] buf = new byte[required_len];
      final int len = scriptpubkey_multisig_from_bytes(bytes, threshold, flags, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] witness_program_from_bytes(byte[] jarg1, long flags) {
      int len = jarg1.length;
      if ((flags & WALLY_SCRIPT_HASH160) != 0)
        len = HASH160_LEN;
      else if ((flags & WALLY_SCRIPT_SHA256) != 0)
        len = SHA256_LEN;
      final byte[] ret = _get_push_buf(len, 1);
      if (witness_program_from_bytes(jarg1, flags, ret) != ret.length)
          throw new IllegalArgumentException("Error encoding witness program");
      return ret;
  }

  public final static byte[] addr_segwit_to_bytes(String jarg1, String jarg2, long jarg3) {
      final byte[] buf = new byte[32 + 2]; /* Largest v0 witness script possible */
      final int len = addr_segwit_to_bytes(jarg1, jarg2, jarg3, buf);
      return trimBuffer(buf, len);
  }

  public final static boolean wif_is_uncompressed(final String wif) {
      return _wif_is_uncompressed(wif) != 0;
  }

  public final static byte[] get_hash_prevouts(byte[] jarg1, int[] jarg3) {
      return get_hash_prevouts(jarg1, jarg3, null);
  }

  public final static byte[] tx_get_hash_prevouts(final Object tx, long index, long num_inputs) {
      return tx_get_hash_prevouts(tx, index, num_inputs, null);
  }

  public final static byte[] tx_get_txid(final Object tx) {
      return tx_get_txid(tx, null);
  }

  public static final byte[] tx_to_bytes(final Object tx, long flags) {
      final int txlength = Wally.tx_get_length(tx, flags);
      final byte[] buf = new byte[txlength];
      final int len = Wally.tx_to_bytes(tx, flags, buf);
      return checkBuffer(buf, len);
  }

  public final static boolean tx_is_coinbase(final Object tx) {
      return _tx_is_coinbase(tx) != 0;
  }

  public final static byte[] tx_get_input_script(Object tx, long jarg2) {
      final byte[] buf = new byte[tx_get_input_script_len(tx, jarg2)];
      final int len = _tx_get_input_script(tx, jarg2, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_input_get_script(Object tx) {
      final byte[] buf = new byte[tx_input_get_script_len(tx)];
      final int len = _tx_input_get_script(tx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_input_witness(Object tx, long jarg2, long jarg3) {
      final byte[] buf = new byte[tx_get_input_witness_len(tx, jarg2, jarg3)];
      final int len = _tx_get_input_witness(tx, jarg2, jarg3, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_input_get_witness(Object tx, long jarg2) {
      final byte[] buf = new byte[tx_input_get_witness_len(tx, jarg2)];
      final int len = _tx_input_get_witness(tx, jarg2, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_output_script(Object tx, long jarg2) {
      final byte[] buf = new byte[tx_get_output_script_len(tx, jarg2)];
      final int len = _tx_get_output_script(tx, jarg2, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_output_get_script(Object tx_out) {
      final byte[] buf = new byte[tx_output_get_script_len(tx_out)];
      final int len = _tx_output_get_script(tx_out, buf);
      return checkBuffer(buf, len);
  }

  public final static long tx_get_input_sequence(final Object tx, final int index) {
    return _tx_get_input_sequence(tx, index) & 0x00000000ffffffffL;
  }

  public final static long tx_input_get_sequence(final Object tx_input) {
      return _tx_input_get_sequence(tx_input) & 0x00000000ffffffffL;
  }

  public final static boolean is_elements_build() {
      return _is_elements_build() != 0;
  }

  public final static byte[] symmetric_key_from_seed(byte[] jarg1) {
      return symmetric_key_from_seed(jarg1, null);
  }

  public final static byte[] symmetric_key_from_parent(byte[] jarg1, long jarg2, byte[] jarg3) {
      return symmetric_key_from_parent(jarg1, jarg2, jarg3, null);
  }

  public final static Object map_init(long jarg1)
  {
      return map_init(jarg1, 0);
  }

  public final static byte[] keypath_get_fingerprint(byte[] jarg1) {
      return keypath_get_fingerprint(jarg1, null);
  }

  public final static int[] keypath_get_path(byte[] keypath) {
      final int[] buf = new int[keypath_get_path_len(keypath)];
      if (buf.length == 0) return buf;
      final int len = keypath_get_path(keypath, buf);
      return checkIntBuffer(buf, len);
  }

  public final static Object psbt_from_bytes(byte[] jarg1) {
      return psbt_from_bytes(jarg1, 0); // Default flags to 0 for back compat.
  }

  public final static Object psbt_from_base64(String jarg1)
  {
      return psbt_from_base64(jarg1, 0); // Default flags to 0 for back compat.
  }

  public final static Object psbt_extract(Object psbt)
  {
      return psbt_extract(psbt, 0); // Default flags to 0 for back compat.
  }

  public final static void psbt_finalize(Object psbt)
  {
      psbt_finalize(psbt, 0); // Default flags to 0 for back compat.
  }

  public final static byte[] psbt_get_input_final_scriptsig(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_final_scriptsig_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_final_scriptsig(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_keypath(Object psbt, long idx, long sub_idx) {
      final byte[] buf = new byte[psbt_get_input_keypath_len(psbt, idx, sub_idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_keypath(psbt, idx, sub_idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_keypath_fingerprint(Object psbt, long idx, long sub_idx) {
      return keypath_get_fingerprint(psbt_get_input_keypath(psbt, idx, sub_idx));
  }

  public final static int[] psbt_get_input_keypath_path(Object psbt, long idx, long sub_idx) {
      return keypath_get_path(psbt_get_input_keypath(psbt, idx, sub_idx));
  }

  public final static byte[] psbt_get_input_previous_txid(Object psbt, long idx) {
      final byte[] buf = new byte[WALLY_TXHASH_LEN];
      return psbt_get_input_previous_txid(psbt, idx, buf);
  }

  public final static byte[] psbt_get_input_redeem_script(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_redeem_script_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_redeem_script(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_signature(Object psbt, long idx, long sub_idx) {
      final byte[] buf = new byte[psbt_get_input_signature_len(psbt, idx, sub_idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_signature(psbt, idx, sub_idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_unknown(Object psbt, long idx, long sub_idx) {
      final byte[] buf = new byte[psbt_get_input_unknown_len(psbt, idx, sub_idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_unknown(psbt, idx, sub_idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_witness_script(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_witness_script_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_witness_script(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_signing_script(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_signing_script_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_signing_script(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_scriptcode(Object psbt, long idx, final byte[] script) {
      final byte[] buf = new byte[psbt_get_input_scriptcode_len(psbt, idx, script)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_scriptcode(psbt, idx, script, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_keypath(Object psbt, long idx, long sub_idx) {
      final byte[] buf = new byte[psbt_get_output_keypath_len(psbt, idx, sub_idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_keypath(psbt, idx, sub_idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_keypath_fingerprint(Object psbt, long idx, long sub_idx) {
      return keypath_get_fingerprint(psbt_get_output_keypath(psbt, idx, sub_idx));
  }

  public final static int[] psbt_get_output_keypath_path(Object psbt, long idx, long sub_idx) {
      return keypath_get_path(psbt_get_output_keypath(psbt, idx, sub_idx));
  }

  public final static byte[] psbt_get_output_redeem_script(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_redeem_script_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_redeem_script(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_script(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_script_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_script(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_witness_script(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_witness_script_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_witness_script(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static void cleanup() {
      _cleanup(0);
  }

  // Support methods for the JNI class (Elements functionality)

  public final static byte[] asset_generator_from_bytes(byte[] jarg1, byte[] jarg2) {
      return asset_generator_from_bytes(jarg1, jarg2, null);
  }

  public final static byte[] asset_final_vbf(long[] jarg1, long jarg2, byte[] jarg3, byte[] jarg4) {
      return asset_final_vbf(jarg1, jarg2, jarg3, jarg4, null);
  }

  public final static byte[] asset_scalar_offset(long jarg1, byte[] jarg2, byte[] jarg3) {
      return asset_scalar_offset(jarg1, jarg2, jarg3, null);
  }

  public final static byte[] asset_value_commitment(long jarg1, byte[] jarg2, byte[] jarg3) {
      return asset_value_commitment(jarg1, jarg2, jarg3, null);
  }

  public final static byte[] asset_rangeproof(long jarg1, byte[] jarg2, byte[] jarg3, byte[] jarg4,
                                              byte[] jarg5, byte[] jarg6, byte[] jarg7, byte[] jarg8,
                                              byte[] jarg9, int jarg10, int jarg11, int jarg12) {
      final byte[] buf = new byte[ASSET_RANGEPROOF_MAX_LEN];
      final int len = asset_rangeproof(jarg1, jarg2, jarg3, jarg4, jarg5, jarg6, jarg7, jarg8,
                                       jarg9, jarg10, jarg11, jarg12, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] asset_surjectionproof(byte[] jarg1, byte[] jarg2, byte[] jarg3,
                                                   byte[] jarg4, byte[] jarg5, byte[] jarg6, byte[] jarg7) {
      final byte[] buf = new byte[asset_surjectionproof_size(jarg5.length / ASSET_TAG_LEN)];
      final int len = asset_surjectionproof(jarg1, jarg2, jarg3, jarg4, jarg5, jarg6, jarg7, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] asset_blinding_key_from_seed(byte[] seed) {
      return asset_blinding_key_from_seed(seed, null);
  }

  public final static byte[] asset_blinding_key_to_ec_private_key(byte[] asset_blinding_key,
                                                                  byte[] script_pub_key) {
      return asset_blinding_key_to_ec_private_key(asset_blinding_key, script_pub_key, null);
  }

  public final static long asset_unblind(byte[] pub_key, byte[] priv_key, byte[] proof,
                                         byte[] commitment, byte[] extra_in,
                                         byte[] generator,
                                         final java.util.List<byte[]> outputs) {
      // We return asset_out, abf_out, vbf_out in the passed list
      for (int i = 0; i < 3; i++) // asset_out, abf_out, vbf_out
          outputs.add(new byte[ASSET_TAG_LEN]);
      return asset_unblind(pub_key, priv_key, proof, commitment, extra_in, generator,
                           outputs.get(0), outputs.get(1), outputs.get(2));
  }

  public final static byte[] confidential_addr_to_ec_public_key(String addr, int prefix) {
      final byte[] buf = new byte[EC_PUBLIC_KEY_LEN];
      confidential_addr_to_ec_public_key(addr, prefix, buf);
      return buf;
  }

  public final static byte[] psbt_get_global_scalar(Object psbt, long idx) {
      final byte[] buf = new byte[WALLY_SCALAR_OFFSET_LEN];
      psbt_get_global_scalar(psbt, idx, buf);
      return buf;
  }

  public final static byte[] psbt_get_input_amount_rangeproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_amount_rangeproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_amount_rangeproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_asset(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_asset_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_asset(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_asset_surjectionproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_asset_surjectionproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_asset_surjectionproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_issuance_amount_commitment(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_issuance_amount_commitment_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_issuance_amount_commitment(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_issuance_amount_rangeproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_issuance_amount_rangeproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_issuance_amount_rangeproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_issuance_blinding_nonce(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_issuance_blinding_nonce_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_issuance_blinding_nonce(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_issuance_asset_entropy(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_issuance_asset_entropy_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_issuance_asset_entropy(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_issuance_amount_blinding_rangeproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_issuance_amount_blinding_rangeproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_issuance_amount_blinding_rangeproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_pegin_claim_script(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_pegin_claim_script_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_pegin_claim_script(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_pegin_genesis_blockhash(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_pegin_genesis_blockhash_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_pegin_genesis_blockhash(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_pegin_txout_proof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_pegin_txout_proof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_pegin_txout_proof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_inflation_keys_commitment(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_inflation_keys_commitment_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_inflation_keys_commitment(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_inflation_keys_rangeproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_inflation_keys_rangeproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_inflation_keys_rangeproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_inflation_keys_blinding_rangeproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_inflation_keys_blinding_rangeproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_inflation_keys_blinding_rangeproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_input_utxo_rangeproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_input_utxo_rangeproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_input_utxo_rangeproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_value_commitment(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_value_commitment_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_value_commitment(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_asset(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_asset_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_asset(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_asset_commitment(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_asset_commitment_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_asset_commitment(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_value_rangeproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_value_rangeproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_value_rangeproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_asset_surjectionproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_asset_surjectionproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_asset_surjectionproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_blinding_public_key(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_blinding_public_key_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_blinding_public_key(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_ecdh_public_key(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_ecdh_public_key_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_ecdh_public_key(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_value_blinding_rangeproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_value_blinding_rangeproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_value_blinding_rangeproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] psbt_get_output_asset_blinding_surjectionproof(Object psbt, long idx) {
      final byte[] buf = new byte[psbt_get_output_asset_blinding_surjectionproof_len(psbt, idx)];
      if (buf.length == 0) return buf;
      final int len = psbt_get_output_asset_blinding_surjectionproof(psbt, idx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_confidential_value_from_satoshi(long satoshi) {
      return tx_confidential_value_from_satoshi(satoshi, null);
  }

  public final static Object tx_elements_input_init(byte[] jarg1, long jarg2, long jarg3, byte[] jarg4) {
      return tx_elements_input_init(jarg1, jarg2, jarg3, jarg4, null, null, null, null, null, null, null, null);
  }

  public final static boolean tx_elements_input_is_pegin(final Object tx_input) {
      return _tx_elements_input_is_pegin(tx_input) != 0;
  }

  public final static byte[] tx_input_get_blinding_nonce(Object tx_input) {
      return tx_input_get_blinding_nonce(tx_input, null);
  }

  public final static byte[] tx_input_get_entropy(Object tx_input) {
      return tx_input_get_entropy(tx_input, null);
  }

  public final static byte[] tx_input_get_issuance_amount(Object tx_input) {
      final byte[] buf = new byte[tx_input_get_issuance_amount_len(tx_input)];
      final int len = _tx_input_get_issuance_amount(tx_input, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_input_get_inflation_keys(Object tx_input) {
      final byte[] buf = new byte[tx_input_get_inflation_keys_len(tx_input)];
      final int len = _tx_input_get_inflation_keys(tx_input, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_input_get_issuance_amount_rangeproof(Object tx_input) {
      final byte[] buf = new byte[tx_input_get_issuance_amount_rangeproof_len(tx_input)];
      final int len = _tx_input_get_issuance_amount_rangeproof(tx_input, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_input_get_inflation_keys_rangeproof(Object tx_input) {
      final byte[] buf = new byte[tx_input_get_inflation_keys_rangeproof_len(tx_input)];
      final int len = _tx_input_get_inflation_keys_rangeproof(tx_input, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_output_get_value(Object tx_out) {
      final byte[] buf = new byte[tx_output_get_value_len(tx_out)];
      final int len = _tx_output_get_value(tx_out, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] tx_output_get_surjectionproof(Object tx_out) {
      final byte[] buf = new byte[tx_output_get_surjectionproof_len(tx_out)];
      final int len = _tx_output_get_surjectionproof(tx_out, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] tx_output_get_rangeproof(Object tx_out) {
      final byte[] buf = new byte[tx_output_get_rangeproof_len(tx_out)];
      final int len = _tx_output_get_rangeproof(tx_out, buf);
      return trimBuffer(buf, len);
  }

  public final static boolean tx_is_elements(final Object tx) {
      return _tx_is_elements(tx) != 0;
  }

  public final static byte[] tx_get_elements_signature_hash(Object tx, long index, byte[] script, byte[] value, long sighash, long flags) {
      return tx_get_elements_signature_hash(tx, index, script, value, sighash, flags, null);
  }

  public final static byte[] asset_pak_whitelistproof(byte[] on_keys, byte[] off_keys, long idx, byte[] sub_pubkey, byte[] priv_key, byte[] summed_key) {
      final int required_len = asset_pak_whitelistproof_size(off_keys.length / Wally.EC_PUBLIC_KEY_LEN);
      final byte[] buf = new byte[required_len];
      final int len = asset_pak_whitelistproof(on_keys, off_keys, idx, sub_pubkey, priv_key, summed_key, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] elements_pegout_script_from_bytes(byte[] bh, byte[] mcs, byte[] pk, byte[] whl, long flags) {
      final int required_len = elements_pegout_script_size(bh.length, mcs.length, pk.length, whl.length);
      final byte[] buf = new byte[required_len];
      final int len = elements_pegout_script_from_bytes(bh, mcs, pk, whl, flags, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] elements_pegin_contract_script_from_bytes(byte[] rs, byte[] cs, long flags) {
      final byte[] buf = new byte[rs.length];
      final int len = elements_pegin_contract_script_from_bytes(rs, cs, flags, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_input_blinding_nonce(Object tx, final int index) {
      return tx_get_input_blinding_nonce(tx, index, null);
  }

  public final static byte[] tx_get_input_entropy(Object tx, final int index) {
      return tx_get_input_entropy(tx, index, null);
  }

  public final static byte[] tx_get_input_issuance_amount(Object tx, final int index) {
      final byte[] buf = new byte[tx_get_input_issuance_amount_len(tx, index)];
      final int len = _tx_get_input_issuance_amount(tx, index, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_input_inflation_keys(Object tx, final int index) {
      final byte[] buf = new byte[tx_get_input_inflation_keys_len(tx, index)];
      final int len = _tx_get_input_inflation_keys(tx, index, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_input_issuance_amount_rangeproof(Object tx, final int index) {
      final byte[] buf = new byte[tx_get_input_issuance_amount_rangeproof_len(tx, index)];
      final int len = _tx_get_input_issuance_amount_rangeproof(tx, index, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_input_inflation_keys_rangeproof(Object tx, final int index) {
      final byte[] buf = new byte[tx_get_input_inflation_keys_rangeproof_len(tx, index)];
      final int len = _tx_get_input_inflation_keys_rangeproof(tx, index, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_output_asset(Object jarg1, int jarg2) {
      return tx_get_output_asset(jarg1, jarg2, null);
  }

  public final static byte[] tx_get_output_value(Object tx, final int index) {
      final byte[] buf = new byte[tx_get_output_value_len(tx, index)];
      final int len = _tx_get_output_value(tx, index, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] tx_get_output_nonce(Object jarg1, int jarg2) {
      return tx_get_output_nonce(jarg1, jarg2, null);
  }

  public final static byte[] tx_get_output_surjectionproof(Object tx, final int index) {
      final byte[] buf = new byte[tx_get_output_surjectionproof_len(tx, index)];
      final int len = _tx_get_output_surjectionproof(tx, index, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] tx_get_output_rangeproof(Object tx, final int index) {
      final byte[] buf = new byte[tx_get_output_rangeproof_len(tx, index)];
      final int len = _tx_get_output_rangeproof(tx, index, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] bip32_key_get_pub_key_tweak_sum(Object jarg1) {
      return bip32_key_get_pub_key_tweak_sum(jarg1, null);
  }

  public final static int[] coinselect_assets(long[] values, long target, long attempts, int io_ratio) {
      final int[] buf = new int[values.length];
      final int len = coinselect_assets(values, target, attempts, io_ratio, buf);
      return trimIntBuffer(buf, len);
  }
}
